## 设计模式

### 一、创建型模型

1. 单例模式
2. 工厂模式
3. 原型模式（克隆模式）

- 	克隆类似于new，但是不同于new，new出来的对象属性是默认值，而克隆则与原型属性相同，但是不影响原型的使用。

> 	原型模式的实现：
		Cloneable接口和clone方法。
		原型模式最困难的地方就是内存复制操作，所幸Java中提供了clone方法。但是这是浅拷		贝，因为对象里面的属性是共用的。
		还可以通过序列化、反序列化实现。

### 二、结构性模型（核心作用：从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题）

1. 适配器模式

> 讲一个接口转换成客户希望的接口，使得原来由于接口不兼容而不能一起工作的能一起工作。适配器可以继承被适配的对象。也可以将被适配的对象添加到适配器的属性中。

2. 代理模式（静态代理）AOP的实现核心

> 通过代理，控制对象的访问，在调用这个方法的前置处理，调用这个方法的后置处理。

- 静态代理：静态定义代理类。
- 动态代理：动态生成代理类。

3. 桥接模式

> 桥接模式可以取代多继承的方案，可以极大的减少子类的个数，提高系统的可扩展性。

4. 组合模式

> 把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象。开发中的应用场景，操作系统的资源管理器，GUI的容器层次图，XML文件解析，OA系统中，组织结构的处理

5. 装饰模式

> 动态的为一个对象增加新的功能，可以代替继承，无须通过继承增加子类就能扩展对象的新功能。

6. 外观模式

> 迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用。

> 外观模式的核心：为子系统提供统一的入口，封装子系统的复杂性，便于客户端的调用。

7. 享元模式

> 应用场景：内存属于稀缺资源，不要随便浪费，如果有多个完全相同或类似的对象，我们可以通过享元模式，节省内存。

> 核心：享元模式已共享的方式支持对象的重用。关键在于区分内部状态和外部状态。

> 内部状态：可以共享，不会随环境变化而改变

> 外部状态：不可以共享，会随环境变化而改变

### 三、行为型模式

1. 责任链模式
> 将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象朱哥判断是否有能力处理请求，如果能，则不传递给下一个对象。

> 应用场景：打牌、接力赛、奖学金审批、公文审批

2. 命令模式

> 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

3. 解释器模式
4. 迭代器模式
> 提供一种遍历聚合对象的方式。

5. 中介者模式

> 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系极其复杂。我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网状结构化解为星状结构。

6. 备忘录模式

> 场景：录入大批人员资料，正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。			

> 文档编辑时，忽然电脑死机或断电，再打开时，可以看到提示你恢复到以前的文档。			管理系统中，公文撤回功能。公文发送出去后，想撤回。

7. 观察者模式
8. 状态模式
9. 策略模式
10. 模板方法模式

> 它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。

> 核心：处理某个流程的代码已经具备，但是其中某个节点代码的代码暂时不能确定。因此，我们采用工厂方法模式，将这个节点的代码转移给子类完成。

11. 访问者模式
